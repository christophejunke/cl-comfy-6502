pattern: ?x  (not bound outside), we know returns match, binding for ?x
matcher: 
  (lambda (form)
     (values t (list form))

pattern: nil
  (lambda (form bindings)
      (values (null form) bindings))

pattern: (?x) (not bound outside)
  (lambda (form bindings)
     (if (consp form)
       (let ((form-cdr (cdr form))
             (form-car (car form)))
	  (m-v-b (car-match ?x-value)  <-- at this point no binding for ?x
               (values t (list form-car))
	     (if car-match
		values (null form-cdr) cdr-bindings) ; matcher nil form-cdr
 	         (values cdr-match cdr-bindings))
           (values nil car-bindings)
       (values nil bindings)))

Lots of m-v-b: looks somewhat clunky.
And the nasty "add-binding" which conses at match time

pattern: (?x) not bound outside

(lambda (form) ; returns values: match, binding for ?x
  (if (not (consp form))
     (values nil nil)
     (let ((form-cdr (cdr form)) 
           (form-car (car form)))
        ;; we know matcher for car returns car-match, binding for x
        (m-v-b (car-match ?x-value)
             (values t form-car)
	   (values (null form-cdr) (list ?x-value))))))
     
pattern: ?x (bound outside)
matcher:
  (lambda (form bindings)
     (values (eql form (bound-value '?x bindings)) bindings))

pattern: (?x ?x) (not bound outside)
  (lambda (form bindings)
     (if (consp form)
       (let ((form-cdr (cdr form))
             (form-car (car form)))
          (m-v-b (cdr-match cdr-bi


;;; These need to be cleaned up.

;;; What I need to do is take a step back and figure out what
;;; is really required from the macro expansion.
;;;
;;; It is not simply the matching function, I need to work in a 
;;; context, namely that of expanding comfy-macros.
;;;
;;; E.g.
;;;
;;; (define-cmacro rr-example
;;;    ((rr-example) '(8 rl))
;;;    ((rr-example ?place) `(seq push 
;;;                               (l ,@?place) 
;;;                               rr-example 
;;;                               (st ,@?place) 
;;;                               pop)))
;;;

(defun rr-expander (form)
  "Returns two values, the first is T if a match was achieved,
the second is then the expansion.
   If no match was possible, the first value is NIL and the 
second is the original form"
  (multiple-value-bind (match-1 expansion-1)
      (let ((car-var (car form))
	    (cdr-var (cdr form)))
	(if (eql car-var 'rr-example)
	    (if (null cdr-var)
		(values t '(8 rl))
		(values nil form))
	    (values nil form)))
    (if match-1 (values match-1 expansion-1)
	(multiple-value-bind (match-2 expansion-2)
	    (let ((car-var (car form))
		  (cdr-var (cdr form)))
	      (if (eql car-var 'rr-example)
		  (let ((?place (car cdr-var))
			(cddr-var (cdr cdr-var)))
		    (if (null cddr-var)
			(values t `(seq push (l ,@?place) 
					rr-example (st ,@?place) 
					pop))
			(values nil form)))
		  (values nil form)))
	  (if match-2 
	      (values match-2 expansion-2)
	      (values nil form))))))

(rr-expander '(rr-example)) 

;; --> T, (8 rl)

(rr-expander '(rr-example (loc)))

;; --> T, (seq push (l loc) rr-example (st loc) pop)xs

(rr-expander '(rr-mismatch))

;;  --> NIL, (RR-MISMATCH)
